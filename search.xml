<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>plugins</title>
      <link href="/plugins/"/>
      <url>/plugins/</url>
      
        <content type="html"><![CDATA[<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><pre><code class="shell">npm install html-webpack-plugin</code></pre><p>这个插件会在打包结束时自动增加一个index.html文件并把打包好的文件引入。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>loader</title>
      <link href="/loader/"/>
      <url>/loader/</url>
      
        <content type="html"><![CDATA[<h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>file-loader用来对文件的打包操作。</p><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>url-loader和file-loader非常相似。不同是url-loader可以把图片编译成base64，并且可以配置limit项，当图片文件大小不大于此项就把图片编译成base64。</p><pre><code class="javascript">&amp;#123;  loader: &#39;url-loader&#39;  options: &amp;#123;    limit: 102400 // 字节单位  &amp;#125;&amp;#125;</code></pre><h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><p>通常配合 <strong>css-loader</strong> 使用，style-loader会把css内容放进页面header的<code>style</code>元素中。</p><p><img src="http://img.phare.xyz/image-20200824133152392.png" alt="image-20200824133152392"></p><h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h3><p>配合style-loader使用，css-loader处理css文件各之间的依赖关系，最终合并成一段css。</p><p>css-loader一些常用配置项</p><table><thead><tr><th>选项</th><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>importLoaders</td><td>处理sass之类的预编译文件时使用，主要用途是在处理css文件引入了其他sass文件时能够完全被sass-loader解析。通常sass-loader是执行循序第一的loader，当我们执行到css-loader时发现发现有引入的sass文件，设置此项可以使得引入的sass文件会重新走一遍loader流程。参数2表示重新走从css-loader开始往前两个loader。</td><td>2</td></tr><tr><td>modules</td><td>开启css模块化打包，配置此项可以使用非全局css</td><td>true</td></tr></tbody></table><h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p>解析sass语法的loader，需要配合上面两个处理css的loader使用。</p><pre><code class="shell">npm install style-loader css-loader sass-loader node-sass -S</code></pre><p>注意，此loader需要配合node-sass插件使用。</p><h3 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h3><p>PostCSS 本身是一个功能比较单一的工具。它提供了一种方式用 JavaScript 代码来处理 CSS。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。插件基于 CSS 代码的 AST 所能进行的操作是多种多样的，比如可以支持变量和混入（mixin），增加浏览器相关的声明前缀，或是把使用将来的 CSS 规范的样式规则转译（transpile）成当前的 CSS 规范支持的格式。从这个角度来说，PostCSS 的强大之处在于其不断发展的插件体系。目前 PostCSS 已经有 200 多个功能各异的插件。开发人员也可以根据项目的需要，开发出自己的 PostCSS 插件。</p><p>下面使用postcss-loader 搭配 <strong>autoprefixer</strong> 实现css3自动添加厂商前缀。</p><ol><li><p>安装<code>postcss-loader</code> 、<code>autoprefixer</code></p><pre><code class="shell">npm install postcss-loader autoprefixer -S</code></pre></li><li><p>项目根目录新建postcss.config.js</p><pre><code class="javascript">modules.export = &amp;#123;  plugins: [    require(&#39;autoprefixer&#39;)  ]&amp;#125;</code></pre><p>输入上面配置，最后别忘记在webpack配置文件中配置使用postcss-loader。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用uniapp遇到的一些问题</title>
      <link href="/%E4%BD%BF%E7%94%A8uniapp%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/%E4%BD%BF%E7%94%A8uniapp%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="动态style没法解析"><a href="#动态style没法解析" class="headerlink" title="动态style没法解析"></a>动态style没法解析</h4><p><img src="http://img.phare.xyz/image-20200817124711705.png" alt="动态style没法解析"></p><pre><code class="javascript">&lt;view class=&quot;container&quot; :style=&quot;temp&quot;&gt;temp = &amp;#123;  width: &#39;777px&#39;,  height: &#39;500px&#39;&amp;#125;</code></pre><p>uniapp不会解析这种形式的对象，可以直接把style写在style属性里或者或像下面这样</p><pre><code class="javascript">&lt;view class=&quot;container&quot; :style=&quot;[temp]&quot;&gt;&lt;view class=&quot;container&quot; :style=&quot;&amp;#123;width: 330px&amp;#125;&quot;&gt;temp = &amp;#123;  width: &#39;777px&#39;,  height: &#39;500px&#39;&amp;#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用插件合集</title>
      <link href="/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/"/>
      <url>/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="concurrently"><a href="#concurrently" class="headerlink" title="concurrently"></a>concurrently</h4><p>当我们需要同时启动多个服务并且想要服务按循序跑起时可以用 <strong>concurrently</strong></p><pre><code class="shell">npm install concurrently -S</code></pre><p>使用方法：</p><p>concurrently service servicce</p><p>“concurrently \“nodemon –watch vue.config.js –exec npm run serve\“ \“electron .\“”</p><p>需要注意的是每端命令都需要使用双引号包起来并且需要使用 \ 转义双引号</p><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h4><p>nodejs自动重启工具</p><p>这个应该就不用多说了，有用过nodejs开发项目肯定都会很烦每次修改后都要重启服务，用了这个插件后可以让我们成为编程语言的主人（狗头）。</p><pre><code class="shell">npm install nodemon -S</code></pre><p>使用也很简单，nodemon app.js 就完事</p>]]></content>
      
      
      <categories>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git时遇到的一些问题</title>
      <link href="/%E4%BD%BF%E7%94%A8git%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/%E4%BD%BF%E7%94%A8git%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="合并代码后没有被改动的文件"><a href="#合并代码后没有被改动的文件" class="headerlink" title="合并代码后没有被改动的文件"></a>合并代码后没有被改动的文件</h4><p>​        git工作流就是如此，不管是 merge 还是 pull 只要没有冲突文件就不会出现被改变的文件。遇到这种情况直接 push 就完事</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作命令小全</title>
      <link href="/git/"/>
      <url>/git/</url>
      
        <content type="html"><![CDATA[<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ol><li><p>git add .</p><p>. 把所有改动文件提交到暂存区。另外可以直接指定某个文件夹或者文件提交</p></li><li><p>git commit -m ‘备注’</p><p>最常见的用法，把暂存区的文件提交到本地版本库。-m 参数代表后面输入提交备注，如果不加 -m 会进入vim让你输入备注</p></li><li><p>git push origin master</p><p>推送本地代码到远程仓库 <strong>origin</strong> 的 <strong>master</strong> 分支</p></li><li><p>git pull origin master</p><p>拉取远程仓库 <strong>origin</strong> 的 <strong>master</strong> 分支的代码到本地git log</p></li></ol><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ol><li><p>git remote</p><p>查看所有远程分支</p></li><li><p>git remote add origin url</p><p>添加远程仓库地址为 <strong>url</strong> 并命名为 <strong>origin</strong></p></li><li><p>git remote rm origin</p><p>删除 <strong>origin</strong> 仓库</p></li><li><p>git remote rename origin dev</p><p>远程仓库 <strong>origin</strong> 重命名为 <strong>dev</strong></p></li></ol><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ol><li><p>git branch</p><p>列出本地分支</p></li><li><p>git branch dev</p><p>创建 <strong>dev</strong> 本地分支</p></li><li><p>git checkout master</p><p>切换到 <strong>master</strong> 分支</p></li><li><p>git merge dev</p><p>当前分支合并 <strong>dev</strong> 分支</p></li><li><p>git branch -d dev</p><p>删除 <strong>dev</strong> 分支</p></li></ol><h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h3><ol><li><p>git log</p><p><img src="http://img.phare.xyz/image-20200817123052864.png" alt="git log"></p><p>使用这个命令可以查看所有提交记录，commit 后面的 hash 码作为指定回滚版本的凭证</p></li><li><p>git reset –hard <code>commitId</code></p><p>回滚至指定版本</p></li><li><p>git reset HEAD</p><p>回滚至上一个版本</p></li><li><p>git reset HEAD~3</p><p>回滚至前3次提交</p></li><li><p>git reset –hard HEAD~1</p><p><strong>撤销commit，并且将commit下的代码也撤销掉</strong></p></li></ol><p><strong>注：使用了 –hard 之后，最新的commit命令下修改的内容将会完全被撤销，慎用。</strong></p><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><ol><li><p>git stash</p><p>将当前改动文件提交到暂存区</p></li><li><p>git pull</p><p>拉取当前分支最新代码</p></li><li><p>git stash pop</p><p>合并冲突文件</p></li></ol><p>接下来需要手动处理冲突文件，建议使用VSCode处理。</p><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><ol><li><p>git tag</p><p>查看所有标签</p></li><li><p>git tag -l [标签]</p><p>查看某个版本的标签</p></li><li><p>git show [标签]</p><p>查看标签详情，可以看到commit内容</p></li><li><p>git push origin [标签]</p><p>推送标签到远程仓库</p></li><li><p>git tag -d [标签]</p><p>删除本地标签</p></li><li><p>git push origin :refs/tags/[标签]</p><p>删除远程标签</p></li></ol><hr><p>更多命令更新中…</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基本配置</title>
      <link href="/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code class="shell">npm install webpack webpack-cli -g</code></pre><p>默认安装最新版，也可以用下面命令指定安装版本。</p><pre><code class="shell">npm install webpack@3.x.x webpack-cli -g</code></pre><p>这种方式是全局安装，不建议使用这种方式。敞若某个项目使用了比当前版本低的webpack将无法运行，所以最好是局部安装，如果不能保证项目所需的webpack版本一致的话。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>基于webpack4.x编写</strong></p><p>webpack默认使用自带配置文件，若项目路径内出现用户自定义的配置文件则使用用户自定义的配置文件。</p><p>新建 webpack.config.js 文件。注意，webpack默认以此文件名文件为配置文件，若我们需要以其他文件名为配置文件，可以使用 –config filename 指令控制</p><p>基本的webpack配置如下</p><pre><code class="js">const path = require(&#39;path&#39;)module.exports = &amp;#123;  mode: &#39;production&#39;  entry: &#39;./index.js&#39;,  output: &amp;#123;    filename: &#39;main.js&#39;    path: path.resolve(__dirname, &#39;build&#39;)  &amp;#125;&amp;#125;</code></pre><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>mode</td><td align="left">当前打包模式，<strong>production</strong> 或 <strong>development</strong>。分别代表生产和开发，区别是生产打包会压缩代码，开发则不会</td></tr><tr><td>entry</td><td align="left">打包目标配置</td></tr><tr><td>output</td><td align="left">打包输出配置</td></tr></tbody></table><p>输出路径不能使用相对路径，需要引入node path模块合并打包文件夹。</p><p>更多配置可参考 <a href="https://www.webpackjs.com/concepts/">webpack中文网</a></p><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>webpack自身只支持对js文件的打包，配置<strong>loader</strong>可以让webpack支持我们想要打包的文件类型。</p><p><strong>注意：loader是有执行循序的，loader的执行循序是从最后一个到第一个，使用时一定要注意循序。</strong></p><p>下面以图片打包为例：</p><ol><li>下载file-loader模块</li></ol><pre><code class="shell">    npm install file-loader -S</code></pre><ol start="2"><li>配置loader使用</li></ol><pre><code class="javascript">const path = require(&#39;path&#39;)module.exports = &amp;#123;  mode: &#39;production&#39;  entry: &#39;./index.js&#39;,  module: &amp;#123;      rules: [          &amp;#123;              test: /\.jpg$/,              use: &amp;#123;                  loader: &#39;file-loader&#39;,                  options: &amp;#123;                      name: &#39;[name].[ext]&#39;,                      outputPath: &#39;imgs/&#39;                    &amp;#125;                &amp;#125;            &amp;#125;      ]    &amp;#125;,  output: &amp;#123;    filename: &#39;main.js&#39;    path: path.resolve(__dirname, &#39;build&#39;)  &amp;#125;&amp;#125;</code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>rules</td><td>打包规则</td></tr><tr><td>test</td><td>正则校验配对文件</td></tr><tr><td>use</td><td>匹配上的文件使用这种配置进行打包</td></tr></tbody></table><p>options是loader的配置项，详情可以查看对应loader提供的配置项。</p><p>上边options配置意思是打包后的文件名保持原本的名称和扩展名 并且输出路径为 <strong>outputPath</strong></p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>plugins是webpack的插件</p><p>配置plugins使用，在webpack配置文件内引入插件，然后在配置项中使用插件。</p><pre><code class="javascript">import htmlWebpackPlugin from &#39;xxx&#39;plugins: [    new htmlWebpackPlugin()]</code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
